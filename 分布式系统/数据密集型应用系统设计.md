## 第三章：数据存储与检索

以一个最简单的数据库实现的例子，来说明数据存储与检索的优化的必要性。

这个例子里，set方法为向一个文本尾部append，get方法为从头遍历一遍该文本，找到对应key的value：

```shell
#!/bin/bash

function db_set(){
  echo "$1,$2" >> database
}

function db_get(){
  grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

可以看到还需要考虑：

1. 多用户并发读写的一致性
2. 回收磁盘空间
3. 控制日志文件大小
4. 错误处理(奔溃恢复)
5. 部分完成写记录（奔溃时只写入部分数据）
6. 查询时的性能

以上几点，最重要的是**查询时的性能**。为了提高查询时的性能，避免每次查询都去从头遍历（O(n)复杂度），就需要一种元数据数据结构来加速。在数据库中，被称为索引。

这种元数据用于描述数据的关系，但不会直接影响数据本身。



### 索引的实现分类

#### K-V模型

##### 哈希索引

最简单的索引策略是，保存内存中的hash map，把每个key都映射到数据文件中特定的字节偏移量，这样就可以找到每个值的位置。Bitcask就是这样的思路。适用于没有太多不一样的key，但每个key都有大量的更新操作，这样可以只在内存中更新。

需考虑如何避免耗尽磁盘空间：可以将日志分解为一定大小的段，当文件达到一定大小时就关闭它，后续写到新的文件中，然后对这些段进行压缩。此处的压缩是指将重复的key-value时，只保留最新的，丢弃旧的。之后可以将压缩处理后的多个段进行合并。。



##### SSTables和LSM-Tree



### 索引的权衡

可以想到，对于写操作，只要建立索引，写性能都不会超过不建立索引的情况。因为每次写操作都需要去更新索引。因此需要权衡索引的建立数量。

