```shell
(gdb) bt
#0  rgw::auth::s3::LocalEngine::authenticate(DoutPrefixProvider const*, boost::basic_string_view<char, std::char_traits<char> > const&, boost::basic_strin
g_view<char, std::char_traits<char> > const&, boost::basic_string_view<char, std::char_traits<char> > const&, std::string const&, std::function<basic_sstr
ing<char, unsigned short, (unsigned short)65> (CephContext*, std::string const&, std::string const&)> const&, std::function<std::shared_ptr<rgw::auth::Com
pleter> (boost::optional<std::string> const&)> const&, req_state const*) const (this=0x7f169a9076c8, dpp=0x7f169c483860, _access_key_id=..., 
    signature=..., session_token=..., string_to_sign="POST\n\ntext/plain\nTue, 01 Jun 2021 09:10:05 +0000\n/bucket0/TESTFILE_10MB?uploads", 
    signature_factory=..., completer_factory=..., s=0x7f169c57dfa0) at /data/ceph/src/rgw/rgw_rest_s3.cc:6346
#1  0x00007f1696a3ab2d in rgw::auth::s3::AWSEngine::authenticate (this=0x7f169a9076c8, dpp=0x7f169c483860, s=0x7f169c57dfa0)
    at /data/ceph/src/rgw/rgw_rest_s3.cc:5283
#2  0x00007f16965a6b29 in rgw::auth::Strategy::authenticate (this=0x7f169a907530, dpp=0x7f169c483860, s=0x7f169c57dfa0)
    at /data/ceph/src/rgw/rgw_auth.cc:226
#3  0x00007f16965a6b29 in rgw::auth::Strategy::authenticate (this=0x7f169a907510, dpp=0x7f169c483860, s=0x7f169c57dfa0)
    at /data/ceph/src/rgw/rgw_auth.cc:226
#4  0x00007f16965a7737 in rgw::auth::Strategy::apply (dpp=0x7f169c483860, auth_strategy=..., s=0x7f169c57dfa0)
    at /data/ceph/src/rgw/rgw_auth.cc:277
#5  0x00007f1696a355c8 in RGW_Auth_S3::authorize (dpp=0x7f169c483860, store=0x7f1699ac7000, auth_registry=..., s=0x7f169c57dfa0)
    at /data/ceph/src/rgw/rgw_rest_s3.cc:4517
#6  0x00007f1696a34e46 in RGWHandler_REST_S3::authorize (this=0x7f169b867ea0, dpp=0x7f169c483860) at /data/ceph/src/rgw/rgw_rest_s3.cc:4438
#7  0x00007f16962fe962 in RGWOp::verify_requester (this=0x7f169c483860, auth_registry=...) at /data/ceph/src/rgw/rgw_op.h:191
#8  0x00007f16964cb059 in process_request (store=0x7f1699ac7000, rest=0x7fff215ac380, req=0x7f169c57e8c0, frontend_prefix="", auth_registry=..., 
    client_io=0x7f169c57e910, olog=0x0, yield=..., scheduler=0x7f169a9caa88, http_ret=0x0) at /data/ceph/src/rgw/rgw_process.cc:302
#9  0x00007f1696378eb6 in (anonymous namespace)::handle_connection<boost::asio::basic_stream_socket<boost::asio::ip::tcp> > (context=..., env=..., 
```

## 代码分析

### string_to_sign的获取

```c++
/* Let's canonize the HTTP headers that are covered by the AWS auth v2. */
std::string string_to_sign;
utime_t header_time;
if (! rgw_create_s3_canonical_header(s->info, &header_time, string_to_sign,
                                     qsr)) {
  ldout(cct, 10) << "failed to create the canonized auth header\n"
    << rgw::crypt_sanitize::auth{s,string_to_sign} << dendl;
  throw -EPERM;
}

ldout(cct, 10) << "string_to_sign:\n"
  << rgw::crypt_sanitize::auth{s,string_to_sign} << dendl;
//----------
/*
 * get the header authentication  information required to
 * compute a request's signature
 */
bool rgw_create_s3_canonical_header(const req_info& info,
                                    utime_t* const header_time,
                                    std::string& dest,
                                    const bool qsr)
{
  const char* const content_md5 = info.env->get("HTTP_CONTENT_MD5");
  if (content_md5) {
    for (const char *p = content_md5; *p; p++) {
      if (!is_base64_for_content_md5(*p)) {
        dout(0) << "NOTICE: bad content-md5 provided (not base64),"
                << " aborting request p=" << *p << " " << (int)*p << dendl;
        return false;
      }
    }
  }

  const char *content_type = info.env->get("CONTENT_TYPE");

  std::string date;
  meta_map_t qs_map;

  if (qsr) {
    get_v2_qs_map(info, qs_map); // handle qs metadata
    date = info.args.get("Expires");
  } else {
    const char *str = info.env->get("HTTP_X_AMZ_DATE");
    const char *req_date = str;
    if (str == NULL) {
      req_date = info.env->get("HTTP_DATE");
      if (!req_date) {
        dout(0) << "NOTICE: missing date for auth header" << dendl;
        return false;
      }
      date = req_date;
    }

    if (header_time) {
      struct tm t;
      if (!parse_rfc2616(req_date, &t)) {
        dout(0) << "NOTICE: failed to parse date for auth header" << dendl;
        return false;
      }
      if (t.tm_year < 70) {
        dout(0) << "NOTICE: bad date (predates epoch): " << req_date << dendl;
        return false;
      }
      *header_time = utime_t(internal_timegm(&t), 0);
    }
  }

  const auto& meta_map = info.x_meta_map;
  const auto& sub_resources = info.args.get_sub_resources();

  std::string request_uri;
  if (info.effective_uri.empty()) {
    request_uri = info.request_uri;
  } else {
    request_uri = info.effective_uri;
  }

  rgw_create_s3_canonical_header(info.method, content_md5, content_type,
                                 date.c_str(), meta_map, qs_map,
				 request_uri.c_str(), sub_resources, dest);
  return true;
}

//------
/*
 * get the header authentication  information required to
 * compute a request's signature
 */
void rgw_create_s3_canonical_header(
  const char* const method,
  const char* const content_md5,
  const char* const content_type,
  const char* const date,
  const meta_map_t& meta_map,
  const meta_map_t& qs_map,
  const char* const request_uri,
  const std::map<std::string, std::string>& sub_resources,
  std::string& dest_str)
{
  std::string dest;

  if (method) {
    dest = method;
  }
  dest.append("\n");
  
  if (content_md5) {
    dest.append(content_md5);
  }
  dest.append("\n");

  if (content_type) {
    dest.append(content_type);
  }
  dest.append("\n");

  if (date) {
    dest.append(date);
  }
  dest.append("\n");

  dest.append(get_canon_amz_hdr(meta_map));
  dest.append(get_canon_amz_hdr(qs_map));
  dest.append(get_canon_resource(request_uri, sub_resources));

  dest_str = dest;
}
```



```c++
/* LocalEngine */
rgw::auth::Engine::result_t
rgw::auth::s3::LocalEngine::authenticate(
  const DoutPrefixProvider* dpp,
  const boost::string_view& _access_key_id,
  const boost::string_view& signature,//传入的用户计算的签名，由用户经由req_state传入
  const boost::string_view& session_token,
  const string_to_sign_t& string_to_sign,
  const signature_factory_t& signature_factory,
  const completer_factory_t& completer_factory,
  const req_state* const s) const
{
  ...
  //server_signature为服务端计算的签名
  const VersionAbstractor::server_signature_t server_signature = \
    signature_factory(cct, k.key, string_to_sign);
  //比较签名是否匹配
  auto compare = signature.compare(server_signature);
```

