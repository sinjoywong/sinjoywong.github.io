# Ceph公共代码梳理

1. [ceph官网：序列化（Encode/Decode）](https://docs.ceph.com/en/latest//dev/encoding/)
2. ceph官方文档：encode与decode： https://docs.ceph.com/en/latest//dev/encoding/
3. Ceph中bufferlist的设计与使用：简单介绍raw,ptr,list：https://blog.csdn.net/ganggexiongqi/article/details/51095869



1. rgw如何保存bucket元数据？

> 对了，SSE-Encryption那个，你有确认过这个情况，对吧？
> 两个RGW同时开着，在一个RGW-A设置，在RGW-B（不需要重启RGW-B的情况下）上可以正确查询到encryption的配置修改。
>
> 我看你的代码里没有特殊修改，所以我比较好奇，RGW是怎么知道你新加的这个扩展属性需要在不同RGW直接同步的。
> 我理解RGW的同步bucket元数据的原理是：修改一个bucket的元数据，rgw会缓存住这个改动，而且rgw会用notify通知其他RGW刷新自己的缓存。但我不太确定，在你新加了encryption这个扩展属性后，RGW怎么知道你新加的这个东西需要缓存和刷新。

2. 每次set是否直接刷写到rados层，还是会缓存？若有缓存，采取什么策略下刷？下刷前如何保证其他rgw可以得到最新数据？
3. encode与decode如何实现？如何考虑升级降级的情况？struct_v

## struct_v是什么？

```c++
void decode(bufferlist::const_iterator& bl) {
    DECODE_START_LEGACY_COMPAT_LEN_32(25, 4, 4, bl);
     decode(bucket, bl);
     if (struct_v >= 2) {
       string s;
```

## bufferlist与结构体的转换

```c++
//rgw_op.cc
void RGWPutObj::execute(){
  ...
  bufferlist tmp;
  RGWCompressionInfo cs_info;
  cs_info.compression_type = plugin->get_type_name();
  cs_info.orig_size = s->obj_size;
  cs_info.blocks = move(compressor->get_compression_blocks());
  ::encode(cs_info, tmp);//全局的::encode(...)，在encoding.h中
  attrs[RGW_ATTR_COMPRESSION] = tmp;
  ...
}

```

### 将bufferlist写入到attr中：

```c++
void RGWPutCORS::execute(){
  ...
    op_ret = retry_raced_bucket_write(store, s, [this] {
      map<string, bufferlist> attrs = s->bucket_attrs;
      attrs[RGW_ATTR_CORS] = cors_bl;
      return rgw_bucket_set_attrs(store, s->bucket_info, attrs, &s->bucket_info.objv_tracker);
    });
  ...
}
  
```

### （深入）attr与ObjectStore

见《Ceph源码分析》 p100，7.2.1对外接口说明： 获取属性以及collection相关的信息。



### 更新bucket attr的考虑

```c++
//rgw_op.cc

// So! Now and then when we try to update bucket information, the
// bucket has changed during the course of the operation. (Or we have
// a cache consistency problem that Watch/Notify isn't ruling out
// completely.)
//
// When this happens, we need to update the bucket info and try
// again. We have, however, to try the right *part* again.  We can't
// simply re-send, since that will obliterate the previous update.
//
// Thus, callers of this function should include everything that
// merges information to be changed into the bucket information as
// well as the call to set it.
//
// The called function must return an integer, negative on error. In
// general, they should just return op_ret.
namespace {
template<typename F>
int retry_raced_bucket_write(RGWRados* g, req_state* s, const F& f) {
  auto r = f();
  for (auto i = 0u; i < 15u && r == -ECANCELED; ++i) {
    r = g->try_refresh_bucket_info(s->bucket_info, nullptr,
				   &s->bucket_attrs);
    if (r >= 0) {
      r = f();
    }
  }
  return r;
}
```



### 写入到attr中与写入到bucket instance info的区别？

```c++
op_ret = retry_raced_bucket_write(store, s, [this] {
  s->bucket_info.bucket_encryption = bucket_encryption;
  op_ret = store->put_bucket_instance_info(s->bucket_info, false,
                                           real_time(), &s->bucket_attrs);
  return op_ret;
});

op_ret = retry_raced_bucket_write(store, s, [this] {
  bufferlist tmp;
  ::encode(bucket_encryption, tmp);
  map<string, bufferlist> attrs = s->bucket_attrs;
  attrs[RGW_ATTR_BUCKET_ENCRYPTION] = tmp;
  return rgw_bucket_set_attrs(store, s->bucket_info, attrs, &s->bucket_info.objv_tracker);
});

```

###  res = get_obj_attrs(store, s, obj, xattrs);是从哪里读取的？

### 从attr中读取

```c++
int RGWLC::bucket_lc_process(string& shard_id){
  RGWLifecycleConfiguration  config(cct);
  ...
  map<string, bufferlist>::iterator aiter = bucket_attrs.find(RGW_ATTR_LC);
  if (aiter == bucket_attrs.end())
    return 0;

  bufferlist::iterator iter(&aiter->second);
  try {
      config.decode(iter);
  ...
  }
}

```

另一个例子：

```c++
int RGWOp::read_bucket_cors()
{
  bufferlist bl;
//这样能否读到？不用从rados里显式地读吗？s的值是什么时候赋值的？
  map<string, bufferlist>::iterator aiter = s->bucket_attrs.find(RGW_ATTR_CORS);
  if (aiter == s->bucket_attrs.end()) {
    ldout(s->cct, 20) << "no CORS configuration attr found" << dendl;
    cors_exist = false;
    return 0; /* no CORS configuration found */
  }

  cors_exist = true;

  bl = aiter->second;

  bufferlist::iterator iter = bl.begin();
  try {
    bucket_cors.decode(iter);
  } catch (buffer::error& err) {
    ldout(s->cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
    return -EIO;
  }
  ...
}
```

#### get_obj_attrs

先从storeget所有的结果到attrs，然后在在其中find：

```c++
void RGWGetObjTags::execute()
{
  rgw_obj obj;
  map<string,bufferlist> attrs;

  obj = rgw_obj(s->bucket, s->object);

  store->set_atomic(s->obj_ctx, obj);

  op_ret = get_obj_attrs(store, s, obj, attrs);
  if (op_ret < 0) {
    ldout(s->cct, 0) << "ERROR: failed to get obj attrs, obj=" << obj
		     << " ret=" << op_ret << dendl;
    return;
  }

  auto tags = attrs.find(RGW_ATTR_TAGS);
  if(tags != attrs.end()){
    has_tags = true;
    tags_bl.append(tags->second);
  }
  send_response_data(tags_bl);
}
```

## 回复给客户端：

```c++
void RGWInitMultipart_ObjStore_S3::send_response()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  for (auto &it : crypt_http_responses)
     dump_header(s, it.first, it.second);
  end_header(s, this, "application/xml");
  if (op_ret == 0) {
    dump_start(s);
    s->formatter->open_object_section_in_ns("InitiateMultipartUploadResult", XMLNS_AWS_S3);
    if (!s->bucket_tenant.empty())
      s->formatter->dump_string("Tenant", s->bucket_tenant);
    s->formatter->dump_string("Bucket", s->bucket_name);
    s->formatter->dump_string("Key", s->object.name);
    s->formatter->dump_string("UploadId", upload_id);
    s->formatter->close_section();
    rgw_flush_formatter_and_reset(s, s->formatter);
  }
}
```

另一个例子：

```c++
void RGWGetCORS_ObjStore_S3::send_response()
{
  if (op_ret) {
    if (op_ret == -ENOENT)
      set_req_state_err(s, ERR_NO_SUCH_CORS_CONFIGURATION);
    else
      set_req_state_err(s, op_ret);
  }
  dump_errno(s);
  if (store->s3_auth_use_cam()) {
    end_header(s, this, "application/xml");
  } else {
    end_header(s, NULL, "application/xml");
  }
  dump_start(s);
  if (! op_ret) {
    string cors;
    RGWCORSConfiguration_S3 *s3cors =
      static_cast<RGWCORSConfiguration_S3 *>(&bucket_cors);
    stringstream ss;

    s3cors->to_xml(ss);
    cors = ss.str();
    dump_body(s, cors);
  }
}
```

## delete逻辑

```c++
void RGWDeleteCORS::execute() 
{
  ...
    op_ret = retry_raced_bucket_write(store, s, [this] {
      op_ret = read_bucket_cors();
      if (op_ret < 0)
        return op_ret;

      if (!cors_exist) {
        ldpp_dout(this, 2) << "No CORS configuration set yet for this bucket" << dendl;
        op_ret = -ENOENT;
        return op_ret;
      }

      map<string, bufferlist> attrs = s->bucket_attrs;
      attrs.erase(RGW_ATTR_CORS);
      op_ret = rgw_bucket_set_attrs(store, s->bucket_info, attrs,
                                    &s->bucket_info.objv_tracker);
      if (op_ret < 0) {
        ldpp_dout(this, 0) << "RGWLC::RGWDeleteCORS() failed to set attrs on bucket=" << s->bucket.name
          << " returned err=" << op_ret << dendl;
      }
      return op_ret;
    });
}
```

另一个参考：

```c++
int RGWLC::remove_bucket_config(RGWBucketInfo& bucket_info,
                                const map<string, bufferlist>& bucket_attrs)
{
  map<string, bufferlist> attrs = bucket_attrs;
  attrs.erase(RGW_ATTR_LC);
  int ret = rgw_bucket_set_attrs(store, bucket_info, attrs,
				&bucket_info.objv_tracker);

  rgw_bucket& bucket = bucket_info.bucket;

  if (ret < 0) {
    ldout(cct, 0) << "RGWLC::RGWDeleteLC() failed to set attrs on bucket="
        << bucket.name << " returned err=" << ret << dendl;
    return ret;
  }
```

## req_state的生命周期

```c++
//rgw_process.cc
int process_request(RGWRados* const store,
                    RGWREST* const rest,
                    RGWRequest* const req,
                    const std::string& frontend_prefix,
                    const rgw_auth_registry_t& auth_registry,
                    RGWRestfulIO* const client_io,
                    OpsLogSocket* const olog,
                    int* http_ret) {
  //从client_io中获取RGWEnv，包括一些基本头信息，如REQUEST_URI,REQUEST_METHOD,HTTP_AUTHORIZATION：
  RGWEnv& rgw_env = client_io->get_env();
  // Check for remap root
  if (store->ctx()->_conf->rgw_map_root != "") {
    std::string uri = rgw_env.get("REQUEST_URI");
    std::string request_method = rgw_env.get("REQUEST_METHOD");
    const char* pszAuth = rgw_env.get("HTTP_AUTHORIZATION");
    if (uri.length() > 0 && uri.find("/", 1) == std::string::npos && !pszAuth && request_method == "GET") {
      rgw_env.set("REQUEST_URI", (store->ctx()->_conf->rgw_map_root + uri).c_str());
    }
  }
  ...
  //初始化一个req_state:
  struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);
  struct req_state *s = &rstate;
  //与RGWObjectCtx建立联系：
  RGWObjectCtx rados_ctx(store, s);
  s->obj_ctx = &rados_ctx;
  //生成一个唯一的req_id:
  s->req_id = store->unique_id(req->id);
  s->trans_id = store->unique_trans_id(req->id);
  s->host_id = store->host_id;
  
  //找到handler，即PUT/GET/DELETE/OPTION/...
  RGWRESTMgr *mgr;
  RGWHandler_REST *handler = rest->get_handler(store, s,
                                               auth_registry,
                                               frontend_prefix,
                                               client_io, &mgr, &init_error);
  ...
  //获得op,并赋值给RGWRequest:
  req->log_format(s, "getting op %d", s->op);
  op = handler->get_op(store);
  req->op = op;
  dout(10) << "op=" << typeid(*op).name() << dendl;
  
  //将op赋值给req_state:
  s->op_type = op->get_type();
  
  //校验：
  req->log(s, "verifying requester");
  ret = op->verify_requester(auth_registry);
  if (ret < 0) {
    dout(10) << "failed to authorize request" << dendl;
    abort_early(s, NULL, ret, handler);
    goto done;
  }
  
  //validate bucket、user, object等：
  req->log(s, "normalizing buckets and tenants");
  ret = handler->postauth_init()
  
  //正式进入处理流程：
  ret = rgw_process_authenticated(handler, op, req, s);

//完成处理后，回调给客户端
done:
  try {
    client_io->complete_request();
}
  
  

//rgw_process.cc
int rgw_process_authenticated(RGWHandler_REST * const handler,
                              RGWOp *& op,
                              RGWRequest * const req,
                              req_state * const s,
                              const bool skip_retarget)
{
  if (! skip_retarget) {
    req->log(s, "recalculating target");
    ret = handler->retarget(op, &op);//此处将从rados中读取该bucket的attrs。对于S3，默认skip_retarget总是false，因此都会进入这里，到这里req_state已经有了该bucket的所有信息（attrs），无需手动去读取（待实际验证）。
    if (ret < 0) {
      return ret;
    }
    req->op = op;
  } else {
    req->log(s, "retargeting skipped because of SubOp mode");
  }
  

//rgw_rest_s3.cc
int RGWHandler_REST_S3Website::retarget(RGWOp* op, RGWOp** new_op) {
  *new_op = op;
  ldout(s->cct, 10) << __func__ << "Starting retarget" << dendl;

  if (!(s->prot_flags & RGW_REST_WEBSITE))
    return 0;

  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);
  int ret = store->get_bucket_info(obj_ctx, s->bucket_tenant,
				  s->bucket_name, s->bucket_info, NULL,
				  &s->bucket_attrs);
  ...
}
```

## req_state->bucket_attrs的获取

> 从RGWRados中读取，放到req_state中。

```mermaid
graph TD
RGWHandler::do_init_permissions
--> RGWOp::rgw_build_bucket_policies
--> rgw_bucket_parse_bucket_instance
rgw_bucket_parse_bucket_instance --s->bucket_instance_id.empty--> get_bucket_info
rgw_bucket_parse_bucket_instance --!s->bucket_instance_id.empty--> get_bucket_instance_info

get_bucket_info --> RGWRados::get_bucket_info
--> RGWRados::_get_bucket_info
--> rgw_make_bucket_entry_name
--> *pattrs=e.attrs

```



```shell
int rgw_build_bucket_policies(RGWRados* store, struct req_state* s){
   ...
   if (!s->bucket_name.empty()) {
   s->bucket_exists = true;
   if (s->bucket_instance_id.empty()) {
   ret = store->get_bucket_info(obj_ctx, s->bucket_tenant, s->bucket_name, s->bucket_info, NULL, &s->bucket_attrs);
   } else {
   ret = store->get_bucket_instance_info(obj_ctx, s->bucket_instance_id, s->bucket_info, NULL, &s->bucket_attrs);
   }
   ...
}
```

## string判断等号

```c++
if(s->dialect.compare("s3") == 0) 
```
